\section{General Linear Interfaces}

The regular \verb|Functor| interface does not work with linear types, as it has unrestricted bindings \cite{eb_idris_qtt_prac}.
Each types defines its own map function, for instance, \verb|LMaybe| defines: 

\begin{minted}{idris}
	(<$>) : (a -@ b) -> LMaybe a -@ LMaybe b
	f <$> Nothing = Nothing
	f <$> Just x = Just (f x)
\end{minted}

Firstly, let us create a "linear functor" interface of roughly the common shape:

\begin{minted}{idris}
	interface NFunctor (f : Type -> Type) where 
		mapL : (a -@ b) -> (f a -@ f b)
\end{minted}

This uses an unrestricted binding. 
However, we can replace this with a $M$ type.

First, let us look at say, \verb|Data.Linear.LVect.(<$>)|:

\begin{listing}
	\begin{minted}{idris}
		(<$>) : (f : a -@ b) -> LVect n a -@ LVect n b
		f <$> [] = []
		f <$> x :: xs = f x :: (f <$> xs)
	\end{minted}
	\caption{\texttt{LVect}'s \texttt{(<\$>)}}
\end{listing}


This requires $f$ unrestricted, even though we know its the same length as the vector.
This is because it is applied once to each element.
Therein, we know it would be preferable to state that we can, in general, for a given type, provide exactly a certain number of usages of the functions only.

We could do this by introducing a field, \verb|req : Nat|.
\begin{listing}
	\begin{minted}{idris}
		interface NFunctor (f : Type -> Type) where 
			0 req : Nat
			mapN : (M req (a -@ b)) -> (f a -@ f b)
	\end{minted}
	\caption{A second $\texttt{NFunctor}$}
\end{listing}

\subsection{Dependent Multiplicities}

However, there is still one large problem with this. 
What about \verb|LMaybe| and \verb|LList|?
These require as many functions as there are elements, which is only known at runtime.
To solve this, we need to generalize \verb|NFucntor| to a dependent multiplicity, specifically, we describe that \verb|NFunctor| is of the full type in \ref{full_nfun} \cite{dep_mult_dep_lin}.

\begin{listing}
	\label{full_nfun}
	\begin{minted}{idris}
		interface NFunctor (f : Type -> Type) where 
			0 req : {a : Type} -> a -@ Nat
			mapN' : (1 x : f a) -> (M (req x) (f a -@ f b)) -@ f b
	\end{minted}
	\caption{Final $\texttt{NFunctor}$}
\end{listing}

Note that we must swap the function and argument order, as the functions depend on the arguement, not the other way around.