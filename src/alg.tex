\section{Resource Algebras as Types}

In many programming languages, algebras are used as a supplement to the type system to model various concepts \cite{effekt} \cite{koka_1} \cite{flix_paper}.
Among these, Granule uses a resource algebra to model multiplicity \cite{quant_graded_modal}.
However, a number of libraries in Haskell use the type system itself to model algebras \needcite{}. 

It stands to reason then that it should be possible, with mu types and Idris' rich type system, to model the resource algebras of Granule.
We do this with \code{Form} types, which model formulas of natural numbers.

\subsection{Formula Language}
\label{sec:form_lang}

Here, we attempt to model a simple affine arithmetic, a more general form of which appears in Granule \cite{quant_graded_modal}.
To determine the interpreation of a given formula, which we call \code{Form}, we create a function $\ni$, which models the notion of a value being a ``possible result'' of the formula

\begin{definition}[Formula Datatype]
  \code{Form} is a simple datatype, with four\footnote{In reality, \code{FAdd} and \code{FMul} form one constructor which takes a opcode as an arguement, since they have the same signature} constructors:
  \begin{itemize}
  \item \code{FVar}, which takes no arguements, which models the notion of a ``variable''
  \item \code{FVal}, which takes in one linear list of linear natural numbers, which models that notion of either a constant or a finite range of possible values
  \item \code{FOp AddOp}, (which we alias as \code{FAdd}) which we write as $\oplus$, having two arguements, models the notion of adding together formulas
  \item \code{FOp MulOp}, (which we alias as \code{FMul}) which we write as $\otimes$, having two arguemetns, which models the noiton of taking the product of formulas
  \end{itemize}
\end{definition}

Likewise, the definition of $\ni$ is quite simple:

\begin{definition}[Formula Usage]
  $\ni$ is a predicate on a \code{Form} and \nat{} such that, $\phi \ni n$ can be defined for each $\phi$ as follows:
  \begin{itemize}
  \item If $\phi$ is $\code{FVar}$, then this is equivalent to $\top$.
  \item If $\phi$ is $\code{FVal} x$, then $x \ni_{\code{List}} n$ is equivalent to $\phi \ni n$  
  \item If $\phi$ is $\fadd{\phi_0}{\phi_1}$ then this is equivalent to $\sg<1>[x]{\nat} \sg<1>[y]{\nat} \sg{x + y \peq n} \sg{\phi_0 \ni x} \phi_1 \ni y$
  \item If $\phi$ is $\fmul{\phi_0}{\phi_1}$ then this is equivalent to $\sg<1>[x]{\nat} \sg<1>[y]{\nat} \sg{x * y \peq n} \sg{\phi_0 \ni x} \phi_1 \ni y$
  \end{itemize}
\end{definition}

Together, these model a formula language with wildcards, ranges, constants, addition, and multiplication.

\subsubsection{Formula Syntax}
\label{sec:form_syntax}

Often, these formulas are unnecasairlly long to write.
For instance, if we want to write the formula whose only solution is $1$, we have to write out $\code{FVal} \left[ 1 \right]$, which is very long.

It is for this reason that in the \thislib{} library, we define an interface \code{Formula}.
This has only one function, which simply takes in the input value and outputs a formula.
Then, whenever, we need to use a formula we simply apply that function (called \code{formula} that then outputs it).
For instance, we define in the library an infix operator $\code{|+|}$, whose type is $\afa{\code{Formula} f} \afa{\code{Formula g}} \fn<1>{f} \fn<1>{g} \vform$, which is define in \ref{fig:add_mul_form_sugar}. 
\begin{figure}
    \label{fig:add_mul_form_sugar}
    \begin{minted}{idris}
        (|+|) : Formula f1 => Formula f2 => f1 -@ f2 -@ Form
        (|+|) f1 f2 = FAdd (formula f1) (formula f2)
        public export
        (|*|) : Formula f1 => Formula f2 => f1 -@ f2 -@ Form
        (|*|) f1 f2 = FMul (formula f1) (formula f2)
    \end{minted}
\end{figure}

Some important things that are also formulas

\begin{itemize}
\item Integers, which just map to $\code{FVal} \left[ n \right]$, where $n$ is the integer
\item Lists of integers, which do similarly.
\item The unit value, $\top$, which maps to $\code{FVar}$
\item Functions of the form $\fn<1>{\code{Form}} f$, where $f$ can also be a formula, to just that applied to $\code{FVar}$
\end{itemize}

\subsection{Unification Of Formulas}
\label{sec:form_rel}

While $\fsolve{\phi}{n}$ relates a formula and a number, often we want to relate two formulas

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
