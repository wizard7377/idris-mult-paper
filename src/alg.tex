\section{Resource Algebras as Types}

In many programming languages, algebras are used as a supplement to the type system to model various concepts \cite{effekt} \cite{koka_1} \cite{flix_paper}.
Among these, Granule uses a resource algebra to model multiplicity \cite{quant_graded_modal}.
However, a number of libraries in Haskell use the type system itself to model algebras \needcite{}. 

It stands to reason then that it should be possible, with mu types and Idris' rich type system, to model the resource algebras of Granule.
We propose that this is indeed possible with a definition of \code{Form'} types.

\subsection{Formula Language}

\begin{definition}
  \code{Form'} is a polymorphic type indexed by a \nat{}.
  We also define a function, $\code{Eval'} : \fn<1> {\code{Form'} n}{\fn{\code{QVect} n \nat}{\nat}}$
  Further, we define a function $\code{Solve'} : \fn<1>{\code{Form'} n}{\fn<1>{\nat}{\tpe}}$, which is defined as $\code{Solve'} \phi x \deq \et<1>[x]{\code{Form'} n}{\code{Eval'} \phi x \peq y}$.
  In addition, we define $\code{Unify'} \phi \psi \deq \fa<1>[n]{\nat}{\fn{\code{Solve'} n \phi}{\code{Solve' n \psi}}}$
\end{definition}

We will write $x \in \phi$ or $\phi \ni x$ for $\code{Solve'} \phi x$, and $\phi \subseteq \psi$ $\psi \supseteq \phi$ for $\code{Unify'} \phi \psi$. 
Notably, this means that $\phi \subseteq \psi := \fa<1>[n]{\nat}{\fn{\phi \ni n}{\psi \ni n}}$.
This allows us to consider formulas as ``sets'' of natural numbers, those being all their possible outputs. 
We then say that a given number is ``in'' the formula if it is possible for it to be output, and a subset if every ``element'' is in the superset. 
We define the interpretation of each constructor of \code{Form'} based off its branch of \code{Eval'}

This means that \code{Form'} forms a category on $\subseteq$
\todo{Need proof}

\subsection{The Core Formulas}

The first \code{Form'} iS these is \code{FVar'}, which has the type $\code{Form'} 1$. 
It models the notion of a singular variable in the formula.
It evaluates as $\code{Eval'} \code{FVar'} [x] \deq x$, notably, however, this is the only branch, as the only possible index that \code{FVar'} can produce is 1.

Of all the formulas, \code{FVar'} is the most general. 
That is to say, it is the terminal object in the category of \code{Form'}. 

\begin{lemma}
  \label{lem:gen_var}
  $\fsolve{\code{FVar'}}{n}$ is trivial.
\end{lemma}
\begin{proof}
  This expands to $\fsolve[x]{\code{FVar'}}{n}$, which, if we have $(n, \alpha)$, where $\alpha$ is $\feval{\code{FVar'}}{n} \peq n$, which is trivial.
\end{proof}

The next of these, \code{FVal'}, models the notion of ``constants'' in formulas.
It has the form $\code{FVal'} : \fn<1>{\nat}{\code{Form'} 0}$, and has the evaluation of $\code{Eval'} (\code{FVal'} n) [] \deq n$

\subsection{The Binary Constructors }
\label{sec:bin_cons}

The remaining constructor models the notion of ``binary operations'' on \code{Form'}.
It allows us to create a very basic tree of quantity expressions, which, combined with \code{FVal'} and \code{FVar'}, allow us to model literals, variables, and ``applications'' of either addition, multiplication, minimims and maximums to those formulas.

It makes use of a enumeration type, \code{FOp}, which are attatched to each operation on two values.
\begin{definition}
  We define $\code{FOp} = + | - | min | max$, and also define \code{runOp} that has the type $\fn<1>{op} \fn<1>{\nat} \fn<1>{\nat} \nat$, such that we map the operation in \code{FOp} to its corresponding two arguement function
\end{definition}

\todo{Notation}

\code{FApp'} then takes that operations and applies it to two formulas.
This allows us to create ``quantity expressions''.
\begin{definition}
  \code{FApp'} is of the type $\code{FApp'} : \fn<1>[op]{\code{FOp}} \fa<1>[a]{\nat} \fa<0>[b]{\nat} \fn<1>{\code{Form'} a} \fn<1>{\code{Form'} b} {(\apply{Form'}{(a + b)})}$.
\end{definition}
\missingcode{}

Note that we \emph{add} the number of variables in the types, and the first number is linear, not erased.
This has to do with the system of variables in \code{Form'}: each variable can only occur once.
While this does limit the power of \code{Form'}, it also makes it substaintally simplifies the solving of \code{Form'}.

This allows us to reason about formulas easily, because we know that each part of the formula can be solved independtly.

\begin{lemma}
  If $\fsolve{\phi}{x}$, and $\fsolve{\psi}{y}$, then $\fsolve{\code{FApp'} op \phi \psi}{(\apply{runOp}{op}) x y}$. 
\end{lemma}

While this dosen't look very intuitive, this is simply the fact that $\fsolve{\phi + \psi}{x + y}$ and so on.

\begin{proof}
  \todo{Proof}
\end{proof}
\subsection{Abstract Forms}
\label{sec:abstract_form}

While so far we have been dealing with formulas with explicit numbers of variables.
However, we almost never actually care about the inputs to a formula, we care only about the outputs.
Neither $x \in \phi$ or $\phi \subseteq \psi$ is dependent on the type of the given formulas.
So, rather than dealing with the ``concrete'' types, we instead deal with an abstract type, \code{Form}, which is a dependent linear pair of the form $\sg<1>[n]{\nat} (\code{Form'} n)$.

We then apply equivalents to each operation that works on \code{Form} instead of \apply{Form'}{n}, and there name is the respective operation, merely with the prime dropped from the end
We also define $\code{Solve}$ and $\code{Unify}$, which are defined likewise.
Finally, we use the same notation for $\code{Form}$ as $\code{Form'} n$, $5$ for $\apply{FVal}{5}$, $\phi + \psi$ for $\code{FAdd} \phi \psi$, and $x \in \phi$ for \code{Solve} and $\phi \subseteq \psi$ for $\code{Unify} \phi \psi$.

Altogether, the formula language is as follows:

\begin{bnf}
  op ::= | $+$ | $*$ | min | max ;;
  $\phi$ : Form ::=
  | $n$ : Number
  | $\_$ : Variable
  | $\phi$ op $\phi$ : Application
\end{bnf}

\subsection{Decidability of Formulas}
\label{sec:form_dec}

One of the reaons this specific set of formula types was chosen is that it allows for $\fsolve{\phi}{n}$ to be provably terminadbly decidable for any formula and natural number.
That is, their is a total function \code{DecSolve} from a formula and natural number to either $\fsolve{\phi}{n}$ or a proof that it is absurd

We prove this by case anaylisis and induction.
Firstly, we have the two base cases:

\begin{lemma}
  \label{lem:dec_fvar}
  $\fsolve{\code{FVar'}}{n}$ is decidable.
\end{lemma}
\begin{proof}
  This reduces to $\fsolve[x]{\code{FVar'}}{n}$, which simply has $(n, \code{Refl})$.
\end{proof}

\begin{lemma}
  \label{lem:dec_fvar}
  $\fsolve{\code{FVal'} v}{n}$ is decidable.
\end{lemma}
\begin{proof}
  This reduces to $\fsolve[x]{\code{FVal' v}}{n}$, which further reduces to $\et<1>[x]{\nat} (v \peq n)$, and, as natural number equality is decidable, is decidable
\end{proof}

Their are 4 more inductive cases, one for each operation.

However, first, we must define the induction hypothesis.
Because for each case they are exactly the same, we note them all here.
\subsection{Formula Syntax Sugar}
\label{sec:formulaic}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
