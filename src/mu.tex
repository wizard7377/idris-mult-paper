\section{$\tmu$ types}

\tmu types aim to serve as a model for multiplicity polymorphism, without extending the core language of Idris.
Moreover, a construction on \tmu, \tomega, can be used to model a form of unrestricted binding.
The \tmu type is indexed on three arguments, a "size", $n : \nat$, a type $t : \tpe$, and a witness of that type, $w : t$ 

\begin{definition}
	The definition of \tmu and its constructors are:
	
	\begin{math}
		\tmu : (n :_0 \nat) \to (t :_0 \tpe) \to (w :_0 t) \to \tpe \\
		\mz : \fa{\tpe} t \fa{t} w (\tmu \ 0 \ t \ w) \\
		\ms : \fa{\tpe} t \fa{\nat} n ((w : t) \proc (\tmu \ n \ t \ w) \proc (\tmu \ (S \ n) \ t \ w))
	\end{math}
\end{definition}

\begin{figure}[h]
	\begin{minted}{idris}
		data M : (n : Nat) -> (t : Type) -> {w : t} -> Type where
			MZ : 
				{0 t : Type} ->
				{0 w : t} ->
				M Z t {w}
			MS : 
				{0 t : Type} -> 
				{0 n : Nat} -> 
				{0 w : t} ->
				(1 w : t) -> 
				(1 xs : Lazy (M n t {w})) -> 
				M (S n) t {w}
	\end{minted}
	\caption{Idris definition of \tmu, as found in \texttt{Data.Mu.Types}}
\end{figure}

\subsection{The Uniqueness Theorem}

\begin{theorem}[Uniqueness of \tmu]
	\label{lem:unique}
	If $\Delta_0$ and $\Delta_1$ both have type $\tmu \ n \ t \ w$, and that type is constructible, then $\Delta_0 \gls{sym:peq} \Delta_1$
\end{theorem}

\begin{proof}
	Let us induce on $n$.
	
	The base case $n \equiv 0$, thereby $\Delta_0$ and $\Delta_1$ are of type $\tmu \ 0 \ t \ w$, which has only one constructor, $\mz$, which is equal to itself.
	
	The inductive case, then involves a proof that $a \nsum \Delta_0' \gls{sym:peq} b \nsum \Delta_1'$, where $\Delta_0' : \tmu \ n \ t \ w$, $\Delta_1' : \tmu \ n \ t \ w$.
	
	We note the type of $\nsum : (w : t) \proc \tmu \ n \ t \ w \proc \tmu \ (S n) \ t \ w$, and attempt to unify $\Delta_0' : \tmu \ n \ t \ w$ with $\tmu \ n \ t \ w$, and then infer the first argument must be of the form $w$.
	Thereby, $a \gls{sym:peq} w$.
	
	Do similar on $b$ and $\Delta_1'$, and we also get $b \gls{sym:peq} w$. 
	We then rewrite, using both these two results $w \nsum \Delta_0' \gls{sym:peq} w \nsum \Delta_1'$, then, we have $\Delta_0' \gls{sym:peq} \Delta_1'$.
	This is the induction hypothesis.
\end{proof}

That is, given the fact that $ \tmu \ n \ t \ w$ is constructable, there must be exactly one inhabitant.

We can establish a number of interesting corollaries, including that products are unique:

\begin{corollary}
	If $\Delta_0$ and $\Delta_1$ both have type $(\tmu \ m \ t \ w_0 \lpair \tmu \ n \ u \ w_1)$, and that type is constructible, then $\Delta_0 \gls{sym:peq} \Delta_1$
\end{corollary}

\begin{proof}
	\todo{Add proof}
\end{proof}

\subsection{Pushing and Pulling}

\label{sec:push_pull}


Of course, at this point, we still can do almost nothing with the \tmu type.
To use it, we will need to define functions to help with its usages, we will start with the \verb|push| and \verb|pull| functions \cite{quant_graded_modal}.
Specifically, we want two functions, $\verb|pushM| : ( \tmu \ n \ (t \lpair u) \ (w_0 \ltup w_1)) \proc (( \tmu \ n \ t \ w_0) \lpair ( \tmu \ n \ u \ w_1))$, and $\verb|pullM| : (( \tmu \ n \ t \ w_0) \lpair ( \tmu \ n \ u \ w_1)) \proc ( \tmu \ n \ (t \lpair u) \ (w_0 \ltup w_1))$.
For the ease of understanding, in Granule syntax, these are \verb|(a, b) [c] → (a [c], b [c])| (for \verb|push|) and \verb|(a [c], b [c]) → (a, b) [c]| (for \verb|pull|) \cite{quant_graded_modal}.
Essentially, these two functions allow us to "distribute" a modality over a linear pair, or invert this "distribution". 

The definitions (in Idris) are as follows 
\begin{minted}{idris}
	pushM MZ = MZ # MZ
	pushM (MS (x # y) z) = 
		let (xs # ys) = pushM z 
		in (MS x {w=x} xs # MS y {w=y} ys)
\end{minted}

and 

\begin{minted}{idris}
	pullM (MZ # MZ) = MZ
	pullM (MS x xs # MS y ys) = 
		MS (x # y) {w=(x # y)} (pullM (xs # ys))
\end{minted}

Note the simultaneous mapping of the values at runtime and the witnesses at type-level, in addition, note that we manipulate the witnesses like what they represent at runtime.

Naturally, these should form an isomorphism.

\begin{lemma}
	\verb|pushM| and \verb|pullM|, form a linear isomorphism between $(\tmu \ n \ (t \lpair u) \ (w_0 \ltup w_1))$ and $((\tmu \ n \ t \ w_0) \lpair (\tmu \ n \ u \ w_1))$
\end{lemma}

\begin{proof}
	It is trivial that the types are indeed those of their respective functions.
	Then, because the argument type of \verb|pushM| is the result type of \verb|pullM|, and vice versa, we can use \ref{lem:unique} to determine that this must map to and from the same object (there is only one possible)
\end{proof}

\subsection{Mapping Linearly}

\label{sec:map_lin}

Next, we define a way to define a \verb|Functor| like \verb|map| on $\tmu$, namely, $\verb|mapM| : (f : t \proc u) \to M \ n \ t \ w \proc M \ n \ u \ (f \ w)$

\todo{Idris definition}

\subsubsection{Applying $M$ to $M$}

\label{sec:app_m_to_m}

Now, for the ability to apply $M$ types.
Firstly, note that in general, in both \gls{qtt} and \gls{grtt}, we need to have an equal number of functions and arguments \cite{eb_idris_qtt_prac, quant_graded_modal}
We can construct a function $\verb|applyLinear| : (a \proc b) \proc a \proc b$, whose term is just $\verb|applyLinear| f x \equiv f x$.
We can then curry \todo{Cite and maybe linear currying?} this function, getting $\verb|applyPair| : ((a \proc b) \lpair a) \proc b$.

In addition two values $x : M n (t \proc u) f$ and $y : M n t w$, we can then construct the linear pair, $(x *^1 y) : M n (t \proc u) f \lpair M n t w$. We can then apply $\verb|pullM|$ to the pair, thereby getting a value of the form $z : M n (t \proc u \lpair t) (f *^1 w)$, and we can then use \verb|mapM applyPair| to get $z : M n u (\verb|applyPair| (f *^1 w))$.
Simplify, and we get $z : M n u (f w)$
\subsection{combining and Spiting}

\label{sec:combine_split}

If we view \tmu as "vectors of linear values", then we should have an equivalent to vector concactination, \verb|++| \cite{idris_linear}.
These correspond with the \gls{grtt} notion of context combination \cite{quant_graded_modal}.
For $M$, we call these $\mcombine$, (in Idris \verb|combine|)

It is defined as follows:

\begin{minted}{idris}
	combine : 
		forall t, n, m. 
		{0 w : t} -> 
		M n t w -@ 
		M m t w -@ 
		M (n + m) t w
	combine {w} MZ ys = ys
	combine {w=x} (MS x xs) ys = MS x {w=x} (combine xs ys)
\end{minted}

This simply combines all the elements in a similar way to a list.
In addition, we also have the inverse of \verb|combine|, \verb|split|\footnote{\texttt{split'} is described here. \texttt{split} essentially leaves the proof that the source does indeed have a index of $n+m$ up to the user with an \texttt{auto} implicit}:

\begin{minted}{idris}
	split' : forall t, w, n. {1 m : Nat} -> M (m + n) t w -@ LPair (M m t w) (M n t w)
	split' {m=Z} xs = MZ # xs
	split' {m=S m} (MS x xs) = let (ys # zs) = split' {m=m} ( xs) in (MS x {w=x} ys # zs)
\end{minted}

\begin{lemma}
	\todo{Finish} split combine inverses
\end{lemma}

\subsection{Squashing and Expanding}

\label{sec:squash_expand}

\todo{Write section}

\subsection{Associativity, Commutativity}

\label{sec:assoc_comm}

\todo{Write section}

\subsection{Conversing Resources}

\todo{Write section}

