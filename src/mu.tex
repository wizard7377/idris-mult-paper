\section{$M$ Types}

The most important construction described here is the $M$ type\footnote{Sometimes the linear exponent $type, \texttt{Copies}$}, which takes two arguments, a multiplicity $n : \nat$\footnote{$\nat$ is the type of natural numbers, in Idris $\texttt{Nat}$}, and a type $t : \ast$\cite{idris_prelude}.

\begin{note}
	$M \ n \ t$, $M_n t$, and $t^n$ are all different notations for the same type
\end{note}

\begin{definition}
	$M$ has two constructors, $\mz$ and $\nsum$.
	
	$\mz$ acts as the trivial case for $M$, having a signature $\mz : M_0 t$.
	It requires no arguments, and is restricted to only producing values where the first index of $M$ is $0$.
	
	$\nsum$ acts as the inductive case for $M$.
	Its signature is $\nsum : t \proc M_n t \proc M_{S n} t$.
	It "adds" one binding two an existing $M_n$, and returns a $M$ whose index is the successor of the arguments index. 
\end{definition}

\begin{listing}
	\begin{minted}{idris}
		data M : (0 n : Nat) -> (t : Type) -> Type where
			MS : (1 x : t) -> (1 xs : (Lazy (M n t))) -> M (S n) t
			MZ : M Z t
	\end{minted}
	\caption{Idris definition of $M$}
\end{listing}
Note that $M$ is \emph{not} a special construction.
It is an ordinary type, with ordinary constructors, that is \emph{already} valid Idris.
This is one of the primary utilities of $M$: it allows us to construct equivalent constructions to those in GrTT in QTT without extending QTT itself.

Also note that $M_n t$ is very different then $!_n t$. 
$M_n t$ requires \emph{exactly} $n$ usages of $t$, while $!_n t$ requires \emph{at most} $n$ usages of $t$. \cite{linear_exponent}

\subsection{Operators of $M$}

There are four main operators relating to $M$, $\mcombine$\footnote{Written $\texttt{combine}$}, and \verb|join|, as well as their inverses, \verb|split| and \verb|expand|.

The first of these, $\mcombine$, acts as a way to "combine" two different sets of bindings into one larger set (in \verb|Data.Linear.Copies|, it is called \verb|++|) \cite{inverse_of_type,idris_linear}.
Its type signature is $\mcombine : M_a t \proc M_b t \proc M_{a+b} t$.
Notably when written using exponential notation, its signature becomes $\mcombine : t^a \proc t^b \proc t^{a+b}$, which looks like the multiplication of exponential. 
Its Idris implementation may be found at \ref{combine_code}

Indeed, if we view $M_n t$ as an $n$-tuple of $t$ containing all identical elements, there is a direct relationship between the constructors and the numbers.
\begin{tabular}{|c|c|c|}
	\hline
	Exponent & Number & M \\
	\hline
	\hline
	$t^0$ & $1$ & $\mz$ \\
	\hline
	$t^1$ & $1*t$ & $\mz \nsum t$ \\
	\hline
	$t^2$ & $1*t*t$ & $\mz \nsum t \nsum t $ \\
	\hline
	$t^3$ & $1*t*t*t$ & $\mz \nsum t \nsum t \nsum t $ \\
	\hline
\end{tabular}

Under this view, $\mcombine$ is the quantitative interpretation of multiplication.
That is, $x \mcombine y = z$ where $x$ is (a) $t^3$, $y$ is (a) $t^2$, and $z$ is (a) $t^5$ is both correct quantitatively and numerically.
More information on the relationship between copies and exponents may be found in \citetitle{inverse_of_type}.

In this case \verb|split| acts as "division". 
Namely, it has the form $\verb|split| : t^{a+b} \proc (t^a \lpair t^b)$.

\verb|join| simplifies "repeat exponentiation". 
Namely, it has the signature $\verb|join| : {t^a}^b \proc t^{a*b}$, which also has the inverse of \verb|expand|, which itself has the signature $\verb|expand| : t^{a*b} \proc {t^a}^b$.

\subsection{Application of $M$}

In discussions of graded types, two procedures are often mentioned, \verb|push| and \verb|pull|.
$M$ has equivalents of these, $\texttt{push} : (a \lpair b)^n \proc (a^n \lpair b^n)$ and $\texttt{pull} : (a^n \lpair b^n) \proc (a \lpair b)^n$ \cite{quant_graded_modal}. 
These are enough to define application of $M$ types.

Specifically, we can define $\verb|apM| : (a \proc b)^n \proc a^n \proc b^n$.
To construct $\verb|apM| f x$ we fist $\verb|pull|$ both of these into a single pair, thereby getting something of the form $\verb|apps| : ((a \proc b) \lpair a)^n$. 
We then simply apply each pair, and get $b^n$.

There is a way to further generalize this application, however. 
Namely, given a $f : (t_0 \proc t_1)^{a+b}$, and $x : {t_0}^{a+c}$, we have $(t_1^a \lpair (t_0 \proc t_1)^b \lpair t_1^c)$.
We construct this by splitting $f$ and $x$, and then applying the relevant section, returning the "unused" portions themselves.