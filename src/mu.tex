\section{$\tmu$ types}

The core construction here is $M$, or, in Idris, \code{Mu}, type.
This is made to model a ``source'' of a given value.
It is indexed by a natural number, a type, and an erased value of that type. 
The definitions of this in Idris are given at \ref{lst:mu_def}.

\begin{definition}
	$M$ is a polymorphic type with signature 
	$M : \oldfn(S m') n : \nat . \oldfn0 t : \tpe . \oldfn0 w : t . \tpe$
\end{definition}

In addition, $M$ has two constructors

\begin{definition}
	There are two constructors of $M$, $\mz$ \code{MZ}, and $\odot$, \code{MS}, Which have the signatures $\mz : \tm n t w$ and $\ms : \oldfn1 w : t . \oldfn1 \_ : {\tm n t w} . \tm {(S n)} t w$ 
\end{definition}

Firstly, it should be noted that the names were chosen due to the fact that the indices of them are related. 
That is, $\mz$  or ``mu zero'' will always be indexed by $0$, and $\ms$, ``mu successor'', is always indexed by the succesor of whatever is given in.

\begin{listing}
	\begin{minted}{idris}
		data Mu : (n : Nat) -> (t : Type) -> (w : t) -> Type where
			MZ : 
				Mu Z t w
			MS : 
				(1 w : t) -> 
				(1 xs : (Mu n t w)) -> 
				Mu (S n) t w
	\end{minted}
	\caption{The definition of $M$ in Idris}
	\label{lst:mu_def}
\end{listing}
\begin{remark}
	\label{remark:only_zero}
	$\tm 0 t w$ can only be constructed by $\mz$.
\end{remark}

Intuitively, $M$ represents $n$ copies of $t$, all with the value $w$, very much inspired by the paper \citetitle{inverse_of_type}.
For instance, if we want to construct $x : \tm 2 {\code{String}} \verb|"value"|$, we can only construct this through \ms, an we know, bu nothing but the first argument of the value, that we must take as a initial argument $\verb|value|$, and as a second value of the form $\tm 1 \code{String} \verb|"value"|$, which we then repeat one more time and get another \verb|"value"| an finally we match $\tm 0 {\code{String}} \verb|"value"|$ and get that we must have $\mz$. 

We can then say that we know that the only constructors of $\tm 2 {\code{String}} \verb|"String"|$ is $\verb|"value"| \ms \verb|"value"| \ms \mz$. Note the similarity between the natural number and the constructors. 
Just as we get 2 by applying \code{S}twice to \code{Z}, we get $\tm 2 {\code{String}} \verb|"value"|$ by applying $\ms$ twice to $\mz$. 
This relationship between $M$ types and numbers is far more extensive, as we will cover later. 

The \code{w}index or ``witness'' is the value being copied.
Notably, if we remove the \code{w}index, we would have $\mz : M n t$, and $\ms : t \to_1 M n t \to_1 M (S n) t$, which is simply \code{LVect.}
The reason that this is undesirable is that we don't want this as it allows for $M$ to have heterogeneous elements. 
However, if we are talking about ``copies'' of something, we know that should all be the exact same.

There are two very basic functions that bear mention with respect to $M$. The first of these is \code{witness}, which is of the form $\code{witness}:_0 \oldfa0 w : t . \tm n t w \to t$.
Note that this is an \emph{erased} function.
Its implementation is quite simple, just being $\code{witness}\{w\} \_ \deq w$, which we can create, as erased functions can return erased values \needcite.
In addition, we also have $\code{drop}: \fn{{\tm 0 t w}}{\top}$, which allows us to drop a value.
Its signature is simple $\code{drop}\mz \deq ()$.

Finally, we have \code{once}, which takes a value of form $M 1$ and extracts it into the value itself.
It has a signature $\code{once}: \oldfn1 \_ : \tm 1 t w . t$, where we have $\code{once}(x \ms \mz) \deq x$

\subsection{Uniqueness}

While \code{w}serves a great purpose in the interpretation of $M$ it perhaps serves an even greater purpose in terms of values of $M$.
We can, using \sigil w, prove that there exists exactly one inhabitant of the type $\tm n t w$, so long as that type is well formed.

\todo{Segway into proof}

\begin{lemma}
	$x : \tm n t w$ only if the concrete value of $x$ contains $n$ applications of $\ms$.
\end{lemma}
\begin{proof}
	Induct on \sigil n, the first case, $\tm 0 t w$, contains zero applications of \ms, as it is \mz.
	The second one splits has $x : M (S n') t w$, and we can destruct on the only possible constructor of $M$ for $S$, $\ms$, and get $y :_1 t$ and $z :_1 M n t w$ where $x \peq (y \ms z)$. 
	We know by the induction hypothesis that $z$ contains exactly $n'$ uses of $\ms$, and we therefore know that the constructor occurs one more times then that, or $S n'$
\end{proof}

This codifies the relationship between $M$ types and natural numbers.
Next we prove that we can establish equality between any two elements of a given $M$ instance.
This is equivalent to the statement ``there exists at most one $M$'' \needcite.

\begin{lemma}
	\label{lem:all_eq}
	If both $x$ and $y$ are of type $\tm n t w$, then $x \peq y$.
\end{lemma}
\begin{proof}
	Induct on $n$.
	\begin{itemize}
		\item The first case, where \sigil x and \sigil y are both $\tm 0 t w$, is trivial because, as per \ref{remark:only_zero} they both must be $\mz$
		\item The inductive case, where, from the fact that for any $a$ and $b$ (both of $\tm n' t w$) we have $a \peq b$, we prove that we have, for \sigil x and \sigil y of $\tm {(S n')} t w$ that $x \peq y$.
		We note that we can destruct both of these, with $x_1 : \tm n' t w$ and $y_1 : \tm n' t w$, into $x = x_0 \ms x_1$ and $y = y_0 \ms y_1$, where we note that both $x_0$ and $y_0$ must be equal to \sigil w, and then we just have the induction hypthesis, $x_1 \peq y_1$
	\end{itemize}
	
	We thereby can simply this to the fact that $\tm n' t w$ has the above property, which is the induction hypothesis.
\end{proof}

\begin{listing}
	\begin{minted}{idris}
		0 unique : 
			{n : Nat} -> {t : Type} -> {w : t} -> 
			{a : Mu n t w} -> {b : Mu n t w} -> 
			(a === b)
		unique {n=Z} {w=w} {a=MZ,b=MZ} = Refl 
		unique {n=(S n')} {w=w} {a=MS w xs, b=MS w ys} = rewrite__impl 
			(\zs => MS w xs === MS w zs)
			(unique {a=ys} {b=xs})
			Refl
	
	\end{minted}
	\caption{Proof of \ref{lem:all_eq} in Idris}
	\label{lst:all_eq}
\end{listing}

\todo[cleanup]{Finish proof}

However, we can make a even more specific statement, given the fact we know that $w$ is an inhabitent of $t$.
\begin{theorem}[Uniqueness]
	\label{thm:unique}
	If $\tm n t w$ is well formed, then it must have \emph{exactly} one inhabitent.
\end{theorem}
\begin{proof}
	We know by \ref{lem:all_eq} that there is \emph{at most} one inhabitent of $\tm n t w$. 
	We then induct on $n$ to show that there must also exist \emph{at least} one inhabitent of the type.
	\begin{itemize}
		\item The first case is that $\tm 0 t w$ is always constructible, which is trivial, as this is just $\mz$.
		\item The second case, that $\tm n' t w$ provides $\tm {(S n')} t w$ being constructible is also trivial, namely, if we have the construction on $\tm n' t w$ as $x$, we \emph{know} that the provided value must be \sigil w.
	\end{itemize}
	
	Given that we can prove that there must be at least and at most one inhabitent, we can prove that there is exactly one inhabitent.
\end{proof}

This is very important for proofs on $M$.
It corresponds to the fact that there is only one way to copy something, to provide another value that is the exact same as the first.

\subsection{Graded Modalities With $M$}

\label{sec:grade_mu}
A claim was made earlier that $M$ types can be used to model graded modalities within QTT.
The way it does this, however, is not by directly equating $M$ types with $[]$ types \cite{quant_graded_modal}.
It instead does this in a similar way to how others have embedded QTT in Agda \cite{lin_dyn_mult_dep,dep_mult_dep_lin}. 

Namely, rather than viewing $\tm n t w$ as the \emph{type} $[t]_n$, we instead view it as the \emph{judgment} $[w] : [t]_r$.
Fortunately, due to the fact that this is Idris 2, we don't need a separate $\Vdash$, as $M$ is a type, which, like any other, can be bound linearly, so, the equivalent to the GrTT statement $\Gamma \vdash [x] : [a]_r$ is $\Gamma \vdash \phi : \tm r a x$, which can be manipulated like any other type.

This is incredibly powerful.
Not only can we reason about graded modalities in Idris, we can reason about them in the language itself, rather than as part of the syntax, which allows us to employ regular proofs on them.
This is very apparent in the way constructions are devised. 
For instance, while Granule requires separate rules for dereliction, we do not, and per as a matter of fact we just define it as \code{once}; a similar relationship exists between weakening and \code{drop}where the exact relationship is shown in \ref{fig:meta_drop}. 


\begin{remark}
	\label{remark:mu_grade_eq}
	We assume that $M n t w$ is equivalent to $[w] : [t]_n$.
\end{remark}

Unfortunately, there is no way to prove this in either language, as $M$ can't be constructed in Granule, and graded modal types don't exist in Idris 2.
 
\begin{figure}
	\begin{prooftree}
		\hypo{\Gamma \vdash \alpha} 
		\infer1[Weak]{\Gamma, [w] : [t]_0 \vdash \alpha}
	\end{prooftree}
	
	\begin{minted}{idris}
		weak : (ctx -@ a) -@ ((LPair ctx (Mu 0 t w)) -@ a)
		weak f (x # MZ) = f x
	\end{minted}
	\label{fig:meta_drop}
	\caption{The meta-logical \code{drop} rule and its Idris 2 equivalent}
\end{figure}

\subsection{Operations on $M$}

There are number of operations that are very important on $M$.
The first of these that we will discuss is combination.
We define this as $\mcombine : \oldfn1 \_ : {\tm m t w} . \oldfn1 \_ : {\tm n t w} . \tm {(m + n)} t w$\missingcode, and we define it inductivly as $\ms \mcombine x \deq x$, and $(a \ms b) \mcombine x \deq a \ms (b \mcombine x)$.
Note the similarity between the natural number indicies and the values, where $0 + x \deq x$ and $(S n) + x \deq S (n + x)$

\todo[cleanup]{Fix the alignement of these}
\begin{figure}
	\begin{align}
		\mz \mcombine &x &\deq x \\
		Z + 	  &x &\deq x
	\end{align}
	\begin{align}
		(a \ms &b) \mcombine &x \deq a \ms &(b &\mcombine x) \\
		(S &n) + &x \deq S &(n &+ x)
	\end{align}
\end{figure}

In addition, using the assumption of \ref{remark:mu_grade_eq}, we can liken the function $\mcombine$ to context concatenation \cite{quant_graded_modal}.
However, unlike Granule, we define this in the language itself.
Per as a matter of fact, it isn't actually possible to construct \mcombine in Granule, as it would require a way to reason about type level equality, which isn't possible.

\begin{lemma}
	\label{lem:combine_comm}
	$\mcombine$ is commutative\footnote{You can also prove associativity and related properties, the proof is the same}, that is, $x \mcombine y \peq y \mcombine x$.
\end{lemma}
\begin{proof}
	These types are the same, and by \ref{thm:unique}, they are equal.
\end{proof}

Given that we can ``add'' (Or, as we will see later, multiply) two $M$, it would seem natural that we could also subtract them.
We can this function, which is the inverse of \code{combine}, \code{split}, which has the signature $\code{split}: \oldfn1 n : \nat . \oldfn1 - : {\tm {(m + n)} t w} . {{\tm m t w} \lpair {\tm n t w}}$.
We actually use this a fair bit more than we use \code{combine}, as \code{split}doesn't impose any restrictions on the witness, which is very useful for when we discuss \carat types.

In a similar manner to how we proved (in \ref{lem:combine_comm}) the commutativity of \mcombine, we can prove that these are inverses.
\todo{Add something on metalogical interpretation}
\begin{lemma}
	\label{lem:split_combine}
	Given that we have $f \deq \code{split}$, and $g \deq {\code{uncurry}}^1 (\mcombine)$\footnote{Given that we have ${\indent uncurry}^1 : {(\oldfn1 \_ : a . \oldfn1 \_ : b . c)} \to \oldfn1 \_ : {(a \lpair b)} . c$}, then $f$ and $g$ are inverses.
\end{lemma}
\begin{proof}
	The type of $f$ is $\oldfn1 \_ : {\tm {(m + n)} t w} . {{\tm m t w} \lpair {\tm n t w}}$, and that of $g$ is $\oldfn1 \_ : {{\tm m t w} \lpair {\tm n t w}} . \tm {(m + n)} t w$, so there composition $f \circ g : \oldfn1 - : {\tm {(m + n)} t w} . \tm {(m + n)} t w$ (the same for $g \circ f$).
	Any function from a unique object and that same unique object is an identity, thereby these are inverses \needcite
\end{proof}

Another relevant construction is multiplicity ``joining'' and its inverse, multiplicity ``expanding''.
\begin{definition}
	We define $\code{join}: \tm m {(\tm n t w)} ?$\footnote{For simplicity, we infer the second witness}.
	Its definition is like that of natural number multiplication, with it defined as follows:
	
	\begin{math}
		\code{join}\mz \deq \mz \\
		\code{join}(x_0 \ms x_1) \deq x_0 \mcombine (\code{join}x_1)
	\end{math} 
\end{definition}

This is equivalent to flattening of values, and bears the same name as the equivalent monadic operation, \code{join}.
Just like \mcombine had the inverse \code{split}, \code{join} has the inverse \code{expand}
\subsection{Applications over $M$}

There is still one crucial operation that we have not yet mentioned, and that is application over $M$.
That is, we want a way to be able to lift a linear function into $M$.
We can do this, and we call it \code{map}, due to its similarity to functorial lifting and its definition may be found \ref{lst:def_map}.


However, there is something unsatisfying about \code{map}.
Namely, the first arguement is unrestricted.
However, we \emph{know} exactly how many of the function we need.
It will simply be the same as the number of arguements.

So, we define another function, \code{app}, which has the type $\code{app}: \oldfn1 f : {\tm n {(\oldfn1 \_ : t . u)} {w_f}} . \oldfn1 x : {\tm n t {w_x}} . {\tm n u {(w_f w_x)}}$, and a defintion given at \ref{lst:def_app}

\begin{listing}
	\begin{multicols}{2}
		\begin{minted}{idris}
			app : Mu n (t -@ u) wf -> Mu n t wx -@ Mu n u (wf wx)
			app MZ MZ = MZ 
			app (MS f fs) (MS x xs) = MS (f x) (app fs xs)
		\end{minted}
		\columnbreak
		\begin{minted}{idris}
			map : (f : t -@ u) -> Mu n t w -@ Mu n u (f w)
			map f MZ = MZ
			map f (MS x xs) = MS (f x) (map {w=x} f xs)
		\end{minted}
	\end{multicols}
	\caption{Definition of \code{map} and \code{app}}
	\label{lst:def_map}
	\label{lst:def_app}
\end{listing}

Notably, if we define a function $\code{genMu}: \oldfn1 x : {!_* t} . \oldfa1 n : \nat . {\tm n t x.{\code{unrestricted}}}$, which is simply defined as $\code{genMu}(\code{MkBang}\_) 0 \deq \mz$ and $\code{genMu}(\code{MkBang}x) (S n) \deq (x \ms (\code{genMu}n (\code{MkBang}x)))$, we can define \code{map}as $\code{map}\{n\} f x \deq \code{app}(\code{genMu}f n) x$ \todo{This isn't exactly correct}.

\subsection{Applicative $M$}

We can use \code{app} to derive equivalents of the \code{push} and \code{pull} methods of \granule, in a similar way to how we can use \code{<*>} to define mappings over pairs.
In Idris, we define $\code{push} : \oldfn1 \_ : \tm n {(\oldsg1 \_ : t . u)} {(\tp1 \_ : w_0 . w_1)} . \oldsg1 \_ : \tm n t w_0 . \tm n u w_1$ and $\code{pull} : \oldfn1 \_ : {\oldsg1 \_ : \tm n t w_0 . \tm n u w_1} . \tm n {(\oldsg1 \_ : t . u)} {(\tp1 \_ : w_0 . w_1)}$.
Their construction is simple, and may be found in \thislib.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
