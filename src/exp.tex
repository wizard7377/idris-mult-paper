\section{Linear Exponential Types}
\label{sec:num}

While $M$ types are themselves interesting, they are not, by themselves, very useful.
This is because they don't actually serve as a model for graded modalities (as they appear in Granule) \cite{granule}.
These require a way to abstract \emph{only} on the type and multiplicity, but \emph{not} to require a given instance.

For this, we need to extend the type system with linear exponential types, written $a^n$, which allow us to abstract over the witness

\subsection{Linear Existentialal Types}

First, however, we must define a Linear Existential Type. 
For a dependent function ($\prod$), with Idris 2's three multiplicities, there are three functions, one for each multiplicity.
For a product, however, there are \emph{9} types, one for each \emph{pair} of multiplicities. 

The one we need is not one of the many defined in \gls{lib:prelude}, \gls{lib:base}, and \gls{lib:linear}.
What we need is a \emph{linear existential}, that is, a dependent product type where the first arguement is erased, and the second depends on the first. 
We can define such a thing in Idris as:

\begin{minted}{idris}
record LExists (f : ty -> Type) where
	constructor LEvidence
	0 fst : ty 
	1 snd : f fst
\end{minted}

This is very much like the \gls{lib:base}'s \verb|Exists|. 
However, that is unrestricted on its second field, which is most certainly not what we want.
 
\subsection{Construction of Exponentials}

We define the exponent, written explicitly as $\carat$ (both here and in the source), as being a function on types. 
Specifically, it is erased (type level function) that takes in a natural number, and a type, and returns a type, and is of form 
\begin{minted}{idris}
	0 (^) : (t : Type) -> (n : Nat) -> Type
	(^) t n = LExists (M n t)
\end{minted}

After binding application \cite{binding_app} is implemented, the will look like
\begin{minted}{idris}
	0 (^) : (t : Type) -> (n : Nat) -> Type
	(^) t n = LExists (w : t) | (M n t w)
\end{minted}

That is, it is a witness of a given type at the \emph{value} level and a given value with the witness at the \emph{type} level.
The important distinction between the exponent type and $M$ type is that $M$ types are indexed over their witness.
This is a very useful property, indeed, this is \ref{lem:unique}. 
However, for a modality, this isn't true, $x : t [2]$ and $y : t [2]$ have the same type, no mater what their actual values are.
\todo{Probably should be more here}

\subsection{From $M$ to Exponentials and Back}

As mentioned previously, exponentials don't fundamentally include any different information then $M$ types.
They merely contain it with a differing place hence differing variance, $M$ at the type level, $\carat$ at the value level.
Moreover, the type level information in $M$ corresponds to the erased $\carat$ level information (the first element of the pair).

Because Idris 2 is also dependently typed, this makes the transformation from term level erased information and type relevant\footnote{But still ultimitly runtime erased} information trivial, we just have to extract the specific values.
We define \verb|inType| (for going to $M$) and \verb|inValue| (for going to $\carat$) as follows:

\begin{minted}{idris}
	
	inType : {0 a : Type} -> (1 ex : (a ^ n)) -> M n a ex.fst
	inType {a=a} ex = sndL ex
	
	inValue : {0 a : Type} -> {0 w : a} -> M n a w -@ (a ^ n)
	inValue {a} {w} x = LEvidence {fst'=w} {snd'=x}
	
\end{minted}

These two operations are inverses of each other \todo{Maybe prove this?}.

Because of this, any function that takes or gives one of these types can be made to take or give the other.
So, for instance, to go from $f : M m t w_0 \proc M n u v_0$ to $g : t^m \proc u^n$, all we must do is $g \equiv \verb|inValue| . f . \verb|inType|$

\subsection{The Numerical Properities of Exponentitation}

We can now get to the linear exponentails numeric like properites.
Note that much of what is descirbed here is discussed at length by \citeauthor{inverse_of_type}.

We already have a couple useful properties.
Firstly, for this discussion, we think of $a^n$ like the exponent operator of arithmetic and $a \mcombine b$ as the multiplication operator. 
To go over laws we have already shown:

\todo{Enumerate the laws}

\subsection{Repeated Application}
