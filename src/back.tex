\section{Background}

\subsection{Copying and Dropping}
\label{sec:copy_drop}

Utlitmatly, one of the notable facts about a language like Rust with single use bindings is the notion of cloning, or copying, a value.
Given that Rust's ownership system can be (partially) modeled by a linear type system, \needcite{}, it makes sense then that Idris' linear library has two interfaces, \code{Duplicable} and \code{Discardable}, which model duplication and droping of linear resources, respectivly.

However, a choice was made not use \code{Duplicable}, and its associated \code{Copies}, for a couple of reasons:

\begin{itemize}
\item It is hard to use in practice
\item It relies heavily on \code{Copies}, which is quite similar to the main construction in this paper, mu types
\end{itemize}

For these reasons, we define a new interface, \code{Copy}, which has two methods, $\code{copy} : \fn<1>{(\fn<1>[x]{a} \fn<1>[y]{a} (p x y))} \fn<1>[z]{a} (p z z)$.
This essientally ``uses a value twice'' in an arbitrary (potentially dependent) function, and an erased proof that $\code{copy} f z \peq f z z$.

We also redefine a \code{Drop} interface that is just \code{Consumable} with a different name, though this is more a style choice than anything else.

\subsection{Linear Functions on Numbers}

While Idris' does have a linear library, there are a couple problems with the support for linear bindings:
\begin{itemize}
\item These are not as well developed as their unrestricted counterparts
\item They can't be converted to their unrestricted counterparts
\end{itemize}

One of the best examples of this is the natural numbers.
Clearly, for any binding of $2$, we expect that to be exactly one binding of $1$ inside a succesor function.
However, this is not the case, rather, Idris by default has it so that data constructor arguements are unrestricted by default.
This is very important for a case like the natural numbers, where this is taken to the extreme, it is almost always impossible to talk about the \code{Nat} datatype in a useful way with linear bindings.

\paragraph{Natural Numbers}

The solution to this, then, is to define the \emph{linear} natural numbers.
While the linear library also defines \code{LNat}, we also don't use that, because of the fact that, again, it relies on the \code{Copies} construction, in addition to already not having that large of an implementation to begin with.
Granted, our version is almost exactly the same, and is defined as follows:


\begin{listing}
	\begin{minted}{idris}
        data QNat : Type where
            Zero : QNat
            Succ : (1 k : QNat) -> QNat
	\end{minted}
	\caption{Definition of linear natural numbers}
	\label{lst:def_qnat}
\end{listing}

The rest of the operations use a model as close to the simple inductive definitions as possible, using \code{copy} instead of the more complex \code{duplicate}.

\paragraph{Conatural Numbers}

\todo{Finish this}

\subsection{Existential Types}

Existential types, regarding dependent types, usually refers to dependent pair ($\Sigma$) types \cite{hottbook}.
In this context, we see the first element of the pair as ``evidence'' for the type of the second element of the pair.
In Idris, this is formalized (in \idris's \citetitle{idris_base}) by stating that the first argument is runtime erased, similarly to which universal quantification is a function that is erased.

However, for our usage here this is not suitable, as we are dealing with principally linear values, and \ident Exists is unrestricted.
Fourtanetly, however, the change from unrestricted to linear existentials is quite trivial, the construction of which may be found at \ref{lst:def_lexists1}

\begin{listing}
	\begin{minted}{idris}
		record Exists (t : Type) (p : (t -> Type)) where
			constructor Evidence
			0 fst' : t 
			1 snd' : p fst'
	\end{minted}
	\caption{Definition of linear existentials}
	\label{lst:def_lexists1}
\end{listing}

Not much is notable about this, we define the operations as is usual, except every time a function would be unrestricted over the second value it is instead linear.
We also have a operator, \code{\#?}, which serves as sugar for this, using \idris's \ident typebind , mechanism.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
