\section{Background}

\subsection{Copying Linear Values}
\label{sec:copy_drop}

Girard's original linear logic has one very large problem\footnote{for usage as a language}, the fact that there is no way to ``duplicate'' premises \cite{linear_logic}.
While this seems like a non-issue, there are some cases where this is completely inadmissible.
For instance, consider the natural numbers.
Using only the logic, it is impossible to define multiplication on two simple linear natural numbers.

This is because if we define multiplication as $0 * n = 0$ and $(S m) * n = (m * n) + n$, this will, unless $m = 1$, have more (or less) than one usage of $n$.
That is, we cannot ensure that we can use the variable mutiple times.
Most interestingly, however, is that this models something important: the cloning of memory.
In a language like Rust (excluding the fact that numbers are \code{Copy}) we can't use a value arbitrary many times.

However, unlike Rust, we cannot have a simple $\code{Clone}$ trait.
This is because $\code{Clone}$ has a side effect: it has to be in a region (which is equivalent to having an effect) \cite{flix_paper}. 
In addition, we wouldn't be able to perform equality reflection on the values.

\begin{definition}[Copying Values]
  \code{Copy} is an interface, indexed on a type, $t$, such that there is a function $\code{copy} : \fn<1>[f]{(\fn<1>[x]{t} \fn<1>[y]{t} (p x y))} \fn<1>[z]{t} (p z z)$
\end{definition}
 

\begin{figure}
	\begin{prooftree}
		\hypo{\Gamma , (x : t) , (y : t) , x \peq y \vdash (p x y) } 
		\infer1[Copy]{\Gamma, (z : t) \vdash (p z z) }
	\end{prooftree}
	\label{fig:back_copy}
	\caption{The copy rule}
\end{figure}

In other words, take a function that requires two of the same value, and then just use the same value twice, noting its equality

We also have a much simpler drop trait (whose name is also taken from Rust) which given a value destroys it.
In Idris, this just means it pattern matches against it, returning no useful operation, which can be represented by the existence of a function $\code{drop} : \fn<1>[x]{t} \top$.
For instance, we can define $\code{Drop} (x = y)$, because there is only one possible constructor, \code{Refl}.

Most values are \emph{both} copyable and dropable.
Any datatype (or product or sum type) will be dropable if all their components are, and the same for copyable.
The only two notable things that are not dropable or copyable are
\begin{itemize}
\item \code{Type}, as we cannot construct every possible case
\item Functions, as this would require a way to ``use'' a function, which is not in general possible ($\bot -> \alpha$)
\end{itemize}

\paragraph{Cloning}

In practice, however, this definition can be quite diffucult to work with %FINISH

\subsection{Linear Functions on Numbers}

While Idris' does have a linear library, there are a couple problems with the support for linear bindings:
\begin{itemize}
\item These are not as well developed as their unrestricted counterparts
\item They can't be converted to their unrestricted counterparts
\end{itemize}

One of the best examples of this is the natural numbers.
Clearly, for any binding of $2$, we expect that to be exactly one binding of $1$ inside a succesor function.
However, this is not the case, rather, Idris by default has it so that data constructor arguements are unrestricted by default.
This is very important for a case like the natural numbers, where this is taken to the extreme, it is almost always impossible to talk about the \code{Nat} datatype in a useful way with linear bindings.

The solution to this, then, is to define the \emph{linear} natural numbers.
While the linear library also defines \code{LNat}, we also don't use that, because of the fact that, again, it relies on the \code{Copies} construction, in addition to already not having that large of an implementation to begin with.
Granted, our version is almost exactly the same, and is defined as follows:


\begin{listing}
	\begin{minted}{idris}
        data QNat : Type where
            Zero : QNat
            Succ : (1 k : QNat) -> QNat
	\end{minted}
	\caption{Definition of linear natural numbers}
	\label{lst:def_qnat}
\end{listing}

The rest of the operations use a model as close to the simple inductive definitions as possible, using \code{copy} instead of the more complex \code{duplicate}.

\begin{theorem}[Finite Initial]
  \label{thm:fin_init}
  There is a finite list of all the inhabitents of $\sg<1>[n]{\nat} (n \leq v)$, where $z : \nat$
\end{theorem}
\begin{proof}
  TODO
\end{proof}

\subsection{Dependent Pairs}

As is common, in Idris, existentials are modeled as a dependent pair \cite{hottbook} \cite{hott_sets}.
With Idris, however, there is an extra portion to this.
Specifically, we can also change the multiplicity of the first and second element of the pair.
In addition, we can chose to make these linear, unrestricted, or erased.
Because one of the central goals of this is to create a system that does not use unrestricted bindings, we focus only on the linear and erased possibilities.

The possible combinations, and their names in Idris, as well as their constructors, are given below
\begin{tabular}{|c || c | c|}
    \hline{}
    & $0$ & $1$ \\
    \hline{}
    $0$ & $\Sigma^1$, \code{Sigma}, \code{For} & $\exists^1$, \code{Exists}, \code{Given} \\
    \hline{}
    $1$ & $\Sigma^0$, \code{Subset}, \code{Elem} & $\Sigma^1$, \code{Sigma}, \code{For} \\
    \hline{}
\end{tabular}

We write all of these with the same ``typebind'' shorthand, which, when binding application is added, will allow the above to be written as $\code{For} (x : \nat) | (x \peq x)$, for instance \cite{binding_app}.

Each of these has different parts of the pair being ``inspected''.
In an existential statement, we don't care about the scurutinee, so that is irrelevant.
Subset, with its notion of refinement types, dosen't particularly care about the second elements proof, only that it exists.
Finally, $\Sigma$ represents the ``traditional'' dependent pair, were we (might) care about both elements, and so both of them are linear.

Note that because of the nature of erased bindings, there isn't a difference between a type that has only erased at runtime and an bindings that is $0$, so $\Sigma^1$ models both the linear and erased pair.

\subsection{Notable Categories}
\label{sec:idr_cat}

In Haskell, it is common to refer to the category encompassing all of Haskell as \code{Hask}
Here, we do a similar thing, exact for the category of Idris 2 types with functions as morphisms, we call \icat{}.
In addition, for the category of Idris 2 types with linear functions as morphisms, we write $\icat^1$.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
