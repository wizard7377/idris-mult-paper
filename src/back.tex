\section{Background}

\subsection{Copying and Dropping}
\label{sec:copy_drop}

Utlitmatly, one of the notable facts about a language like Rust with single use bindings is the notion of cloning, or copying, a value.
Given that Rust's ownership system can be (partially) modeled by a linear type system, \needcite{}, it makes sense then that Idris' linear library has two interfaces, \code{Duplicable} and \code{Discardable}, which model duplication and droping of linear resources, respectivly.

However, a choice was made not use \code{Duplicable}, and its associated \code{Copies}, for a couple of reasons:

\begin{itemize}
\item It is hard to use in practice
\item It relies heavily on \code{Copies}, which is quite similar to the main construction in this paper, mu types
\end{itemize}

For these reasons, we define a new interface, \code{Copy}, which has two methods, $\code{copy} : \fn<1>{(\fn<1>[x]{a} \fn<1>[y]{a} (p x y))} \fn<1>[z]{a} (p z z)$.
This essientally ``uses a value twice'' in an arbitrary (potentially dependent) function, and an erased proof that $\code{copy} f z \peq f z z$.

We also redefine a \code{Drop} interface that is just \code{Consumable} with a different name, though this is more a style choice than anything else.

\subsection{Linear Functions on Numbers}

While Idris' does have a linear library, there are a couple problems with the support for linear bindings:
\begin{itemize}
\item These are not as well developed as their unrestricted counterparts
\item They can't be converted to their unrestricted counterparts
\end{itemize}

One of the best examples of this is the natural numbers.
Clearly, for any binding of $2$, we expect that to be exactly one binding of $1$ inside a succesor function.
However, this is not the case, rather, Idris by default has it so that data constructor arguements are unrestricted by default.
This is very important for a case like the natural numbers, where this is taken to the extreme, it is almost always impossible to talk about the \code{Nat} datatype in a useful way with linear bindings.

\paragraph{Natural Numbers}

The solution to this, then, is to define the \emph{linear} natural numbers.
While the linear library also defines \code{LNat}, we also don't use that, because of the fact that, again, it relies on the \code{Copies} construction, in addition to already not having that large of an implementation to begin with.
Granted, our version is almost exactly the same, and is defined as follows:


\begin{listing}
	\begin{minted}{idris}
        data QNat : Type where
            Zero : QNat
            Succ : (1 k : QNat) -> QNat
	\end{minted}
	\caption{Definition of linear natural numbers}
	\label{lst:def_qnat}
\end{listing}

The rest of the operations use a model as close to the simple inductive definitions as possible, using \code{copy} instead of the more complex \code{duplicate}.

\begin{theorem}[Finite Initial]
  \label{thm:fin_init}
  There is a finite list of all the inhabitents of $\sg<1>[n]{\nat} (n \leq v)$, where $z : \nat$
\end{theorem}
\begin{proof}
  TODO
\end{proof}
\paragraph{Conatural Numbers}

\todo{Finish this}

\subsection{Dependent Pairs}

As is common, in Idris, existentials are modeled as a dependent pair \cite{hottbook} \cite{hott_sets}.
With Idris, however, there is an extra portion to this.
Specifically, we can also change the multiplicity of the first and second element of the pair.
In addition, we can chose to make these linear, unrestricted, or erased.
Because one of the central goals of this is to create a system that does not use unrestricted bindings, we focus only on the linear and erased possibilities.

The possible combinations, and their names in Idris, as well as their constructors, are given below
\begin{tabular}{|c || c | c|}
    \hline{}
    & $0$ & $1$ \\
    \hline{}
    $0$ & $\Sigma^1$, \code{Sigma}, \code{For} & $\exists^1$, \code{Exists}, \code{Given} \\
    \hline{}
    $1$ & $\Sigma^0$, \code{Subset}, \code{Elem} & $\Sigma^1$, \code{Sigma}, \code{For} \\
    \hline{}
\end{tabular}

We write all of these with the same ``typebind'' shorthand, which, when binding application is added, will allow the above to be written as $\code{For} (x : \nat) | (x \peq x)$, for instance \cite{binding_app}.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
